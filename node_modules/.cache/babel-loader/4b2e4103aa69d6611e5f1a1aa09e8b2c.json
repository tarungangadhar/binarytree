{"ast":null,"code":"import { options } from \"../config\";\nclass Node {\n  constructor(value) {\n    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    this.id = Node.counter;\n    Node.counter++;\n    this.parent = parent;\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n  _convert(item) {\n    let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return isNaN(item) ? parseInt(item.charCodeAt(i), 10) : parseInt(item, 10);\n  }\n  _handleEqual(item, itemValue, thisValue) {\n    if (isNaN(item)) {\n      let index = 1;\n      while (itemValue === thisValue) {\n        itemValue = this._convert(item, index);\n        thisValue = this._convert(this.value, index);\n        index++;\n        if (index >= this.value.length) {\n          this.addRightChild(item);\n          return;\n        }\n        if (index >= item.length) {\n          this.addLeftChild(item);\n          return;\n        }\n      }\n      if (itemValue === thisValue) {\n        this.addLeftChild(item);\n      } else {\n        this._compareValues(item, itemValue, thisValue);\n      }\n    } else {\n      // same number, insert at left child\n      this.addLeftChild(item);\n    }\n  }\n  _compareValues(item, itemValue, thisValue) {\n    if (itemValue < thisValue) {\n      this.addLeftChild(item);\n    } else if (itemValue > thisValue) {\n      this.addRightChild(item);\n    } else {\n      // special case for equality\n      this._handleEqual(item, itemValue, thisValue);\n    }\n  }\n  addLeftChild(item) {\n    this.left ? this.left.insert(item) : this.left = new Node(item, this);\n  }\n  addRightChild(item) {\n    this.right ? this.right.insert(item) : this.right = new Node(item, this);\n  }\n  insert(item) {\n    let itemValue = this._convert(item);\n    if (this.value) {\n      let thisValue = this._convert(this.value);\n      this._compareValues(item, itemValue, thisValue);\n    } else {\n      this.value = item;\n    }\n  }\n  toGraph() {\n    let isRoot = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let edges = this.parent ? [{\n      from: this.parent.id,\n      to: this.id\n    }] : [];\n    let nodes = this.value ? [{\n      id: this.id,\n      label: this.value,\n      shape: isRoot ? \"box\" : options.nodes.shape\n    }] : [];\n    if (this.left) {\n      let leftRes = this.left.toGraph(false);\n      edges = [...edges, ...leftRes.edges];\n      nodes = [...nodes, ...leftRes.nodes];\n    }\n    if (this.right) {\n      let rightRes = this.right.toGraph(false);\n      edges = [...edges, ...rightRes.edges];\n      nodes = [...nodes, ...rightRes.nodes];\n    }\n    return {\n      nodes,\n      edges\n    };\n  }\n}\nNode.counter = 0;\nexport { Node as BinaryTree };","map":{"version":3,"names":["options","Node","constructor","value","parent","arguments","length","undefined","id","counter","left","right","_convert","item","i","isNaN","parseInt","charCodeAt","_handleEqual","itemValue","thisValue","index","addRightChild","addLeftChild","_compareValues","insert","toGraph","isRoot","edges","from","to","nodes","label","shape","leftRes","rightRes","BinaryTree"],"sources":["D:/BinaryTree-master/src/tree-lib/BinaryTree.js"],"sourcesContent":["import {options} from \"../config\";\n\nclass Node {\n    static counter = 0;\n\n    constructor(value, parent = null) {\n        this.id = Node.counter;\n        Node.counter++;\n\n        this.parent = parent;\n        this.value = value;\n        this.left = null;\n        this.right = null;\n    }\n\n    _convert(item, i = 0) {\n        return isNaN(item) ? parseInt(item.charCodeAt(i), 10) : parseInt(item, 10);\n    }\n\n    _handleEqual(item, itemValue, thisValue) {\n        if (isNaN(item)) {\n            let index = 1;\n            while (itemValue === thisValue) {\n                itemValue = this._convert(item, index);\n                thisValue = this._convert(this.value, index);\n                index++;\n\n                if (index >= this.value.length) {\n                    this.addRightChild(item);\n                    return;\n                }\n                if (index >= item.length) {\n                    this.addLeftChild(item);\n                    return;\n                }\n            }\n            if (itemValue === thisValue) {\n                this.addLeftChild(item)\n            } else {\n                this._compareValues(item, itemValue, thisValue);\n            }\n\n        } else {\n            // same number, insert at left child\n            this.addLeftChild(item)\n        }\n    }\n\n    _compareValues(item, itemValue, thisValue) {\n        if (itemValue < thisValue) {\n            this.addLeftChild(item)\n        } else if (itemValue > thisValue) {\n            this.addRightChild(item)\n        } else {\n            // special case for equality\n            this._handleEqual(item, itemValue, thisValue);\n        }\n    }\n\n    addLeftChild(item) {\n        this.left ? this.left.insert(item) : this.left = new Node(item, this);\n    }\n\n    addRightChild(item) {\n        this.right ? this.right.insert(item) : this.right = new Node(item, this);\n    }\n\n    insert(item) {\n        let itemValue = this._convert(item);\n        if (this.value) {\n            let thisValue = this._convert(this.value);\n            this._compareValues(item, itemValue, thisValue)\n        } else {\n            this.value = item;\n        }\n    }\n\n    toGraph(isRoot = true) {\n        let edges = this.parent ?\n            [\n                {\n                    from: this.parent.id,\n                    to: this.id\n                }\n            ] : [];\n        let nodes = this.value ?\n            [\n                {\n                    id: this.id,\n                    label: this.value,\n                    shape: isRoot? \"box\" : options.nodes.shape\n                }\n            ] : [];\n        if (this.left) {\n            let leftRes = this.left.toGraph(false);\n            edges = [...edges, ...leftRes.edges];\n            nodes = [...nodes, ...leftRes.nodes];\n        }\n        if (this.right) {\n            let rightRes = this.right.toGraph(false);\n            edges = [...edges, ...rightRes.edges];\n            nodes = [...nodes, ...rightRes.nodes];\n        }\n\n        return {\n            nodes,\n            edges\n        }\n    }\n\n}\n\nexport {Node as BinaryTree};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}